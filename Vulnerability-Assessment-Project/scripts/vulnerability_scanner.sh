#!/bin/bash

# Vulnerability Assessment and Penetration Testing Script
# Educational Purpose Only - Use in authorized environments only
# This script automates network scanning, vulnerability assessment, and brute-force testing

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default credential lists (update paths as needed)
DEFAULT_USERNAME_LIST="/usr/share/wordlists/metasploit/unix_users.txt"
DEFAULT_PASSWORD_LIST="/usr/share/wordlists/metasploit/unix_passwords.txt"

# Function to check if a tool is installed
is_tool_installed() {
    command -v "$1" >/dev/null 2>&1
}

# Function to install missing tools
install_and_update_tools() {
    echo -e "${YELLOW}[*] Checking for required tools...${NC}"
    
    required_tools=("nmap" "searchsploit" "hydra" "curl" "jq" "zip")
    missing_tools=()
    
    for tool in "${required_tools[@]}"; do
        if ! is_tool_installed "$tool"; then
            missing_tools+=("$tool")
            echo -e "${RED}[-] $tool is not installed${NC}"
        else
            echo -e "${GREEN}[+] $tool is installed${NC}"
        fi
    done
    
    if [ ${#missing_tools[@]} -gt 0 ]; then
        echo -e "${YELLOW}[*] Installing missing tools...${NC}"
        sudo apt-get update
        sudo apt-get install -y "${missing_tools[@]}"
    fi
}

# Function to get network input
get_network_input() {
    read -p "Enter the network range (e.g., 192.168.1.0/24): " network_range
    
    # Validate network range format
    if ! [[ $network_range =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}$ ]]; then
        echo -e "${RED}[-] Invalid network format. Please use format: xxx.xxx.xxx.xxx/xx${NC}"
        get_network_input
    fi
    
    echo "$network_range"
}

# Function to get output directory
get_output_directory() {
    read -p "Save output in current directory? (yes/no): " save_current
    
    if [[ "${save_current,,}" == "yes" ]]; then
        output_dir=$(pwd)
    elif [[ "${save_current,,}" == "no" ]]; then
        read -p "Enter the output directory path: " output_dir
        mkdir -p "$output_dir"
    else
        echo -e "${RED}[-] Invalid choice. Please enter 'yes' or 'no'${NC}"
        get_output_directory
    fi
    
    echo "$output_dir"
}

# Function to get scan type
get_scan_type() {
    read -p "Choose scan type (basic/full): " scan_type
    
    if [[ "${scan_type,,}" != "basic" && "${scan_type,,}" != "full" ]]; then
        echo -e "${RED}[-] Invalid choice. Please enter 'basic' or 'full'${NC}"
        get_scan_type
    fi
    
    echo "${scan_type,,}"
}

# Function to perform TCP scan
tcp_scan() {
    local network_range=$1
    local output_file=$2
    local scan_type=$3
    
    echo -e "${BLUE}[*] Starting TCP scan on $network_range${NC}"
    
    if [[ "$scan_type" == "basic" ]]; then
        nmap -sS -sV "$network_range" -oN "$output_file"
    else
        nmap -sS -sV -sC -A -O "$network_range" -oN "$output_file"
    fi
    
    echo -e "${GREEN}[+] TCP scan completed. Results saved to $output_file${NC}"
}

# Function to extract service ports
extract_service_ports() {
    local scan_results=$1
    declare -A service_ports
    
    while IFS= read -r line; do
        if [[ $line =~ ([0-9]+)/tcp[[:space:]]+open[[:space:]]+([^[:space:]]+) ]]; then
            port="${BASH_REMATCH[1]}"
            service="${BASH_REMATCH[2],,}"
            service_ports["$service"]="$port"
        fi
    done < "$scan_results"
    
    # Return service ports as string
    for service in "${!service_ports[@]}"; do
        echo "$service:${service_ports[$service]}"
    done
}

# Function for vulnerability mapping
vulnerability_mapping() {
    local scan_results=$1
    local output_file=$2
    
    echo -e "${BLUE}[*] Starting vulnerability mapping...${NC}"
    echo -e "\n\n========== Vulnerability Assessment Results ==========" >> "$output_file"
    
    # Extract unique services and versions
    grep -E "[0-9]+/tcp.*open" "$scan_results" | while read -r line; do
        if [[ $line =~ ([^[:space:]]+)[[:space:]]+([0-9.]+) ]]; then
            service="${BASH_REMATCH[1]}"
            version="${BASH_REMATCH[2]}"
            
            echo -e "\n[*] Checking $service $version" >> "$output_file"
            searchsploit "$service $version" >> "$output_file" 2>&1
        fi
    done
    
    echo -e "${GREEN}[+] Vulnerability mapping completed${NC}"
}

# Function to get credential lists
get_credential_lists() {
    read -p "Use default username and password lists? (yes/no): " use_default
    
    if [[ "${use_default,,}" == "yes" ]]; then
        username_list="$DEFAULT_USERNAME_LIST"
        password_list="$DEFAULT_PASSWORD_LIST"
    elif [[ "${use_default,,}" == "no" ]]; then
        read -p "Enter path to username list: " username_list
        read -p "Enter path to password list: " password_list
        
        if [[ ! -f "$username_list" || ! -f "$password_list" ]]; then
            echo -e "${RED}[-] Invalid file paths${NC}"
            get_credential_lists
        fi
    else
        echo -e "${RED}[-] Invalid choice${NC}"
        get_credential_lists
    fi
    
    echo "$username_list:$password_list"
}

# Function for service selection
select_services() {
    echo "Select services to brute-force (comma-separated):"
    echo "Available: ftp, ssh, rdp, telnet, all"
    read -p "Your choice: " services
    
    if [[ "${services,,}" == "all" ]]; then
        echo "ftp ssh rdp telnet"
    else
        echo "${services//,/ }"
    fi
}

# Function for brute-force attacks
brute_force_attack() {
    local ip=$1
    local service=$2
    local port=$3
    local username_list=$4
    local password_list=$5
    local output_file=$6
    
    echo -e "${YELLOW}[*] Starting brute-force on $service at $ip:$port${NC}"
    
    case "$service" in
        ssh)
            hydra -vV -L "$username_list" -P "$password_list" "$ip" ssh -s "$port" -o "$output_file.hydra" 2>&1
            ;;
        ftp)
            hydra -vV -L "$username_list" -P "$password_list" "$ip" ftp -s "$port" -o "$output_file.hydra" 2>&1
            ;;
        telnet)
            hydra -vV -L "$username_list" -P "$password_list" "$ip" telnet -s "$port" -o "$output_file.hydra" 2>&1
            ;;
        rdp)
            hydra -vV -L "$username_list" -P "$password_list" "$ip" rdp -s "$port" -o "$output_file.hydra" 2>&1
            ;;
    esac
    
    if grep -q "login:" "$output_file.hydra" 2>/dev/null; then
        echo -e "${GREEN}[+] Credentials found for $service!${NC}"
        grep "login:" "$output_file.hydra"
    else
        echo -e "${RED}[-] No credentials found for $service${NC}"
    fi
}

# Function to search results
search_results() {
    local output_file=$1
    
    read -p "Enter search term: " search_term
    echo -e "${BLUE}[*] Searching for: $search_term${NC}"
    grep -i "$search_term" "$output_file"
}

# Function to zip results
zip_results() {
    local output_dir=$1
    
    read -p "Zip all results? (yes/no): " zip_choice
    
    if [[ "${zip_choice,,}" == "yes" ]]; then
        zip_file="$output_dir/scan_results_$(date +%Y%m%d_%H%M%S).zip"
        zip -r "$zip_file" "$output_dir"/*.txt "$output_dir"/*.hydra 2>/dev/null
        echo -e "${GREEN}[+] Results zipped to: $zip_file${NC}"
    fi
}

# Main execution
main() {
    echo -e "${BLUE}========================================${NC}"
    echo -e "${BLUE}   Vulnerability Assessment Scanner    ${NC}"
    echo -e "${BLUE}========================================${NC}"
    echo -e "${RED}[!] FOR EDUCATIONAL PURPOSES ONLY [!]${NC}"
    echo -e "${RED}[!] Use only on authorized systems [!]${NC}\n"
    
    # Install/update tools
    install_and_update_tools
    
    # Get user inputs
    network_range=$(get_network_input)
    output_dir=$(get_output_directory)
    scan_type=$(get_scan_type)
    
    # Create output files
    timestamp=$(date +%Y%m%d_%H%M%S)
    scan_output="$output_dir/tcp_scan_$timestamp.txt"
    
    # Perform TCP scan
    tcp_scan "$network_range" "$scan_output" "$scan_type"
    
    # Extract services
    services=$(extract_service_ports "$scan_output")
    
    # Vulnerability mapping
    vulnerability_mapping "$scan_output" "$scan_output"
    
    # Brute-force section
    read -p "Perform brute-force attacks? (yes/no): " do_bruteforce
    
    if [[ "${do_bruteforce,,}" == "yes" ]]; then
        creds=$(get_credential_lists)
        username_list="${creds%%:*}"
        password_list="${creds##*:}"
        
        selected_services=$(select_services)
        
        # Parse scan results for IPs and perform brute-force
        grep -oE "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" "$scan_output" | sort -u | while read -r ip; do
            for service_data in $services; do
                service="${service_data%%:*}"
                port="${service_data##*:}"
                
                if [[ " $selected_services " =~ " $service " ]]; then
                    brute_force_attack "$ip" "$service" "$port" "$username_list" "$password_list" "$scan_output"
                fi
            done
        done
    fi
    
    # Search results option
    read -p "Search results? (yes/no): " do_search
    if [[ "${do_search,,}" == "yes" ]]; then
        search_results "$scan_output"
    fi
    
    # Zip results
    zip_results "$output_dir"
    
    echo -e "\n${GREEN}[+] Assessment completed!${NC}"
    echo -e "${BLUE}[*] Results saved in: $output_dir${NC}"
}

# Run main function
main "$@"