#!/usr/bin/env python3

"""
Vulnerability Assessment and Penetration Testing Script
Educational Purpose Only - Use in authorized environments only
This script automates network scanning, vulnerability assessment, and brute-force testing
"""

import os
import sys
import re
import subprocess
import argparse
from datetime import datetime
import ipaddress
import json
import zipfile
from pathlib import Path

# Color codes for terminal output
class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    NC = '\033[0m'  # No Color

class VulnerabilityScanner:
    def __init__(self):
        self.required_tools = ['nmap', 'searchsploit', 'hydra', 'curl', 'jq']
        self.default_username_list = "/usr/share/wordlists/metasploit/unix_users.txt"
        self.default_password_list = "/usr/share/wordlists/metasploit/unix_passwords.txt"
        self.service_ports = {}
        self.vulnerable_services = set()
        
    def print_banner(self):
        """Display the script banner"""
        print(f"{Colors.BLUE}{'='*50}{Colors.NC}")
        print(f"{Colors.BLUE}   Vulnerability Assessment Scanner    {Colors.NC}")
        print(f"{Colors.BLUE}{'='*50}{Colors.NC}")
        print(f"{Colors.RED}[!] FOR EDUCATIONAL PURPOSES ONLY [!]{Colors.NC}")
        print(f"{Colors.RED}[!] Use only on authorized systems [!]{Colors.NC}\n")
    
    def is_tool_installed(self, tool):
        """Check if a tool is installed"""
        try:
            subprocess.run([tool, '--version'], capture_output=True, check=False)
            return True
        except FileNotFoundError:
            return False
    
    def install_and_update_tools(self):
        """Check for and install missing tools"""
        print(f"{Colors.YELLOW}[*] Checking for required tools...{Colors.NC}")
        missing_tools = []
        
        for tool in self.required_tools:
            if self.is_tool_installed(tool):
                print(f"{Colors.GREEN}[+] {tool} is installed{Colors.NC}")
            else:
                print(f"{Colors.RED}[-] {tool} is not installed{Colors.NC}")
                missing_tools.append(tool)
        
        if missing_tools:
            print(f"{Colors.YELLOW}[*] Installing missing tools...{Colors.NC}")
            try:
                subprocess.run(['sudo', 'apt-get', 'update'], check=True)
                subprocess.run(['sudo', 'apt-get', 'install', '-y'] + missing_tools, check=True)
            except subprocess.CalledProcessError as e:
                print(f"{Colors.RED}[-] Failed to install tools: {e}{Colors.NC}")
                sys.exit(1)
    
    def validate_network_range(self, network_range):
        """Validate network range format"""
        try:
            ipaddress.ip_network(network_range)
            return True
        except ValueError:
            return False
    
    def get_network_input(self):
        """Get and validate network range from user"""
        while True:
            network_range = input("Enter the network range (e.g., 192.168.1.0/24): ")
            if self.validate_network_range(network_range):
                return network_range
            print(f"{Colors.RED}[-] Invalid network format. Please use format: xxx.xxx.xxx.xxx/xx{Colors.NC}")
    
    def get_output_directory(self):
        """Get output directory from user"""
        while True:
            save_current = input("Save output in current directory? (yes/no): ").lower()
            
            if save_current == "yes":
                return os.getcwd()
            elif save_current == "no":
                output_dir = input("Enter the output directory path: ")
                Path(output_dir).mkdir(parents=True, exist_ok=True)
                return output_dir
            else:
                print(f"{Colors.RED}[-] Invalid choice. Please enter 'yes' or 'no'{Colors.NC}")
    
    def get_scan_type(self):
        """Get scan type from user"""
        while True:
            scan_type = input("Choose scan type (basic/full): ").lower()
            if scan_type in ['basic', 'full']:
                return scan_type
            print(f"{Colors.RED}[-] Invalid choice. Please enter 'basic' or 'full'{Colors.NC}")
    
    def tcp_scan(self, network_range, output_file, scan_type):
        """Perform TCP scan using nmap"""
        print(f"{Colors.BLUE}[*] Starting TCP scan on {network_range}{Colors.NC}")
        
        if scan_type == "basic":
            cmd = ['nmap', '-sS', '-sV', network_range, '-oN', output_file]
        else:
            cmd = ['nmap', '-sS', '-sV', '-sC', '-A', '-O', network_range, '-oN', output_file]
        
        try:
            subprocess.run(cmd, check=True)
            print(f"{Colors.GREEN}[+] TCP scan completed. Results saved to {output_file}{Colors.NC}")
        except subprocess.CalledProcessError as e:
            print(f"{Colors.RED}[-] Scan failed: {e}{Colors.NC}")
            return False
        return True
    
    def extract_service_ports(self, scan_results_file):
        """Extract service ports from scan results"""
        self.service_ports = {}
        
        try:
            with open(scan_results_file, 'r') as f:
                content = f.read()
                
            # Regex to find open ports and services
            pattern = r'(\d+)/tcp\s+open\s+(\S+)'
            matches = re.findall(pattern, content)
            
            for port, service in matches:
                service_lower = service.lower()
                self.service_ports[service_lower] = port
                
            return self.service_ports
        except Exception as e:
            print(f"{Colors.RED}[-] Error extracting services: {e}{Colors.NC}")
            return {}
    
    def vulnerability_mapping(self, scan_results_file):
        """Perform vulnerability mapping using searchsploit"""
        print(f"{Colors.BLUE}[*] Starting vulnerability mapping...{Colors.NC}")
        
        try:
            with open(scan_results_file, 'r') as f:
                content = f.read()
            
            with open(scan_results_file, 'a') as f:
                f.write("\n\n========== Vulnerability Assessment Results ==========\n")
                
                # Find services with versions
                pattern = r'(\d+)/tcp\s+open\s+(\S+)\s+(.+)'
                matches = re.findall(pattern, content)
                
                for port, service, version_info in matches:
                    if (service, port) not in self.vulnerable_services:
                        self.vulnerable_services.add((service, port))
                        f.write(f"\n[*] Checking {service} {version_info}\n")
                        
                        # Run searchsploit
                        try:
                            result = subprocess.run(
                                ['searchsploit', f"{service} {version_info}"],
                                capture_output=True,
                                text=True,
                                check=False
                            )
                            f.write(result.stdout)
                        except Exception as e:
                            f.write(f"Error running searchsploit: {e}\n")
            
            print(f"{Colors.GREEN}[+] Vulnerability mapping completed{Colors.NC}")
        except Exception as e:
            print(f"{Colors.RED}[-] Vulnerability mapping failed: {e}{Colors.NC}")
    
    def get_credential_lists(self):
        """Get username and password lists from user"""
        while True:
            use_default = input("Use default username and password lists? (yes/no): ").lower()
            
            if use_default == "yes":
                return self.default_username_list, self.default_password_list
            elif use_default == "no":
                username_list = input("Enter path to username list: ")
                password_list = input("Enter path to password list: ")
                
                if os.path.exists(username_list) and os.path.exists(password_list):
                    return username_list, password_list
                print(f"{Colors.RED}[-] Invalid file paths{Colors.NC}")
            else:
                print(f"{Colors.RED}[-] Invalid choice{Colors.NC}")
    
    def select_services(self):
        """Allow user to select services for brute-force"""
        print("Select services to brute-force (comma-separated):")
        print("Available: ftp, ssh, rdp, telnet, all")
        services = input("Your choice: ").lower()
        
        if services == "all":
            return ["ftp", "ssh", "rdp", "telnet"]
        else:
            return [s.strip() for s in services.split(',')]
    
    def brute_force_attack(self, ip, service, port, username_list, password_list, output_dir):
        """Perform brute-force attack using hydra"""
        print(f"{Colors.YELLOW}[*] Starting brute-force on {service} at {ip}:{port}{Colors.NC}")
        
        output_file = os.path.join(output_dir, f"hydra_{service}_{ip}_{port}.txt")
        
        cmd = [
            'hydra', '-vV',
            '-L', username_list,
            '-P', password_list,
            ip, service,
            '-s', port,
            '-o', output_file
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=False)
            
            if "login:" in result.stdout or "password:" in result.stdout:
                print(f"{Colors.GREEN}[+] Credentials found for {service}!{Colors.NC}")
                # Extract and display found credentials
                for line in result.stdout.split('\n'):
                    if "login:" in line:
                        print(f"  {line}")
            else:
                print(f"{Colors.RED}[-] No credentials found for {service}{Colors.NC}")
                
            # Save output
            with open(output_file, 'w') as f:
                f.write(result.stdout)
                f.write(result.stderr)
                
        except Exception as e:
            print(f"{Colors.RED}[-] Brute-force failed: {e}{Colors.NC}")
    
    def search_results(self, output_file):
        """Search through results file"""
        search_term = input("Enter search term: ")
        print(f"{Colors.BLUE}[*] Searching for: {search_term}{Colors.NC}")
        
        try:
            with open(output_file, 'r') as f:
                for line in f:
                    if search_term.lower() in line.lower():
                        print(line.strip())
        except Exception as e:
            print(f"{Colors.RED}[-] Search failed: {e}{Colors.NC}")
    
    def zip_results(self, output_dir):
        """Zip all results into a single file"""
        zip_choice = input("Zip all results? (yes/no): ").lower()
        
        if zip_choice == "yes":
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            zip_filename = os.path.join(output_dir, f"scan_results_{timestamp}.zip")
            
            try:
                with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for root, dirs, files in os.walk(output_dir):
                        for file in files:
                            if file.endswith(('.txt', '.log', '.hydra')):
                                file_path = os.path.join(root, file)
                                arcname = os.path.relpath(file_path, output_dir)
                                zipf.write(file_path, arcname)
                
                print(f"{Colors.GREEN}[+] Results zipped to: {zip_filename}{Colors.NC}")
            except Exception as e:
                print(f"{Colors.RED}[-] Failed to zip results: {e}{Colors.NC}")
    
    def extract_ips_from_scan(self, scan_file):
        """Extract unique IPs from scan results"""
        ips = set()
        try:
            with open(scan_file, 'r') as f:
                content = f.read()
                # Find IP addresses
                ip_pattern = r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
                found_ips = re.findall(ip_pattern, content)
                ips.update(found_ips)
        except Exception as e:
            print(f"{Colors.RED}[-] Error extracting IPs: {e}{Colors.NC}")
        return list(ips)
    
    def run(self):
        """Main execution function"""
        self.print_banner()
        
        # Install/update tools
        self.install_and_update_tools()
        
        # Get user inputs
        network_range = self.get_network_input()
        output_dir = self.get_output_directory()
        scan_type = self.get_scan_type()
        
        # Create output files
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        scan_output = os.path.join(output_dir, f"tcp_scan_{timestamp}.txt")
        
        # Perform TCP scan
        if not self.tcp_scan(network_range, scan_output, scan_type):
            return
        
        # Extract services
        self.extract_service_ports(scan_output)
        
        # Vulnerability mapping
        self.vulnerability_mapping(scan_output)
        
        # Brute-force section
        do_bruteforce = input("Perform brute-force attacks? (yes/no): ").lower()
        
        if do_bruteforce == "yes":
            username_list, password_list = self.get_credential_lists()
            selected_services = self.select_services()
            
            # Get IPs from scan results
            target_ips = self.extract_ips_from_scan(scan_output)
            
            # Perform brute-force for each IP and service
            for ip in target_ips:
                for service in selected_services:
                    if service in self.service_ports:
                        port = self.service_ports[service]
                        self.brute_force_attack(
                            ip, service, port,
                            username_list, password_list,
                            output_dir
                        )
        
        # Search results option
        do_search = input("Search results? (yes/no): ").lower()
        if do_search == "yes":
            self.search_results(scan_output)
        
        # Open in text editor option
        open_editor = input("Open results in default text editor? (yes/no): ").lower()
        if open_editor == "yes":
            try:
                if sys.platform == "win32":
                    os.startfile(scan_output)
                elif sys.platform == "darwin":
                    subprocess.run(["open", scan_output])
                else:
                    subprocess.run(["xdg-open", scan_output])
            except Exception as e:
                print(f"{Colors.YELLOW}[!] Could not open file: {e}{Colors.NC}")
        
        # Zip results
        self.zip_results(output_dir)
        
        print(f"\n{Colors.GREEN}[+] Assessment completed!{Colors.NC}")
        print(f"{Colors.BLUE}[*] Results saved in: {output_dir}{Colors.NC}")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Vulnerability Assessment and Penetration Testing Tool',
        epilog='For educational purposes only. Use on authorized systems only.'
    )
    parser.add_argument('-v', '--version', action='version', version='%(prog)s 1.0')
    args = parser.parse_args()
    
    scanner = VulnerabilityScanner()
    
    try:
        scanner.run()
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}[!] Script interrupted by user{Colors.NC}")
        sys.exit(0)
    except Exception as e:
        print(f"{Colors.RED}[-] Unexpected error: {e}{Colors.NC}")
        sys.exit(1)

if __name__ == "__main__":
    main()